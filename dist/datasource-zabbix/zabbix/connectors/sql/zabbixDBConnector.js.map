{"version":3,"sources":["../../../../../src/datasource-zabbix/zabbix/connectors/sql/zabbixDBConnector.js"],"names":["convertGrafanaTSResponse","time_series","items","addHostName","hosts","_","uniqBy","flatten","map","grafanaSeries","itemid","series","name","item","find","alias","keys","length","host","hostid","datapoints","cloneDeep","points","target","sortBy","compactSQLQuery","query","replace","buildSQLHistoryQuery","itemids","table","timeFrom","timeTill","intervalSec","aggFunction","dialect","buildPostgresHistoryQuery","buildMysqlHistoryQuery","buildSQLTrendsQuery","valueColumn","buildPostgresTrendsQuery","buildMysqlTrendsQuery","time_expression","itemid_format","DEFAULT_QUERY_LIMIT","HISTORY_TO_TABLE_MAP","TREND_TO_TABLE_MAP","consolidateByFunc","consolidateByTrendColumns","ZabbixDBConnector","sqlDataSourceId","options","backendSrv","datasourceSrv","limit","loadSQLDataSource","datasourceId","ds","getAll","loadDatasource","then","sqlDataSourceType","meta","id","Promise","reject","testQuery","TEST_MYSQL_QUERY","TEST_POSTGRES_QUERY","invokeSQLQuery","intervalMs","consolidateBy","Math","ceil","grouped_items","groupBy","promises","value_type","join","all","results","includes","history","queryDef","refId","format","rawSql","maxDataPoints","datasourceRequest","url","method","data","queries","response"],"mappings":";;;;;;;;;;;;;AA0JA;;AAEA,WAASA,wBAAT,CAAkCC,WAAlC,EAA+CC,KAA/C,EAAsDC,WAAtD,EAAmE;AACjE,QAAIC,QAAQC,EAAEC,MAAF,CAASD,EAAEE,OAAF,CAAUF,EAAEG,GAAF,CAAMN,KAAN,EAAa,OAAb,CAAV,CAAT,EAA2C,QAA3C,CAAZ,CADiE,CACC;AAClE,QAAIO,gBAAgBJ,EAAEG,GAAF,CAAMP,WAAN,EAAmB,kBAAU;AAC/C,UAAIS,SAASC,OAAOC,IAApB;AACA,UAAIC,OAAOR,EAAES,IAAF,CAAOZ,KAAP,EAAc,EAAC,UAAUQ,MAAX,EAAd,CAAX;AACA,UAAIK,QAAQF,KAAKD,IAAjB;AACA,UAAIP,EAAEW,IAAF,CAAOZ,KAAP,EAAca,MAAd,GAAuB,CAAvB,IAA4Bd,WAAhC,EAA6C;AAAE;AAC7C,YAAIe,OAAOb,EAAES,IAAF,CAAOV,KAAP,EAAc,EAAC,UAAUS,KAAKM,MAAhB,EAAd,CAAX;AACAJ,gBAAQG,KAAKN,IAAL,GAAY,IAAZ,GAAmBG,KAA3B;AACD;AACD;AACA;AACA,UAAIK,aAAaf,EAAEgB,SAAF,CAAYV,OAAOW,MAAnB,CAAjB;AACA,aAAO;AACLC,gBAAQR,KADH;AAELK,oBAAYA;AAFP,OAAP;AAID,KAfmB,CAApB;;AAiBA,WAAOf,EAAEmB,MAAF,CAASf,aAAT,EAAwB,QAAxB,CAAP;AACD;;AAED,WAASgB,eAAT,CAAyBC,KAAzB,EAAgC;AAC9B,WAAOA,MAAMC,OAAN,CAAc,MAAd,EAAsB,GAAtB,CAAP;AACD;;AAED,WAASC,oBAAT,CAA8BC,OAA9B,EAAuCC,KAAvC,EAA8CC,QAA9C,EAAwDC,QAAxD,EAAkEC,WAAlE,EAA+EC,WAA/E,EAA+G;AAAA,QAAnBC,OAAmB,uEAAT,OAAS;;AAC7G,QAAIA,YAAY,UAAhB,EAA4B;AAC1B,aAAOC,0BAA0BP,OAA1B,EAAmCC,KAAnC,EAA0CC,QAA1C,EAAoDC,QAApD,EAA8DC,WAA9D,EAA2EC,WAA3E,CAAP;AACD,KAFD,MAEO;AACL,aAAOG,uBAAuBR,OAAvB,EAAgCC,KAAhC,EAAuCC,QAAvC,EAAiDC,QAAjD,EAA2DC,WAA3D,EAAwEC,WAAxE,CAAP;AACD;AACF;;AAED,WAASI,mBAAT,CAA6BT,OAA7B,EAAsCC,KAAtC,EAA6CC,QAA7C,EAAuDC,QAAvD,EAAiEC,WAAjE,EAA8EC,WAA9E,EAA2FK,WAA3F,EAA2H;AAAA,QAAnBJ,OAAmB,uEAAT,OAAS;;AACzH,QAAIA,YAAY,UAAhB,EAA4B;AAC1B,aAAOK,yBAAyBX,OAAzB,EAAkCC,KAAlC,EAAyCC,QAAzC,EAAmDC,QAAnD,EAA6DC,WAA7D,EAA0EC,WAA1E,EAAuFK,WAAvF,CAAP;AACD,KAFD,MAEO;AACL,aAAOE,sBAAsBZ,OAAtB,EAA+BC,KAA/B,EAAsCC,QAAtC,EAAgDC,QAAhD,EAA0DC,WAA1D,EAAuEC,WAAvE,EAAoFK,WAApF,CAAP;AACD;AACF;;AAED;AACA;AACA;;AAEA,WAASF,sBAAT,CAAgCR,OAAhC,EAAyCC,KAAzC,EAAgDC,QAAhD,EAA0DC,QAA1D,EAAoEC,WAApE,EAAiFC,WAAjF,EAA8F;AAC5F,QAAIQ,iCAA+BT,WAA/B,WAAgDA,WAApD;AACA,QAAIP,4CACyBgB,eADzB,sBACyDR,WADzD,mCAEKJ,KAFL,+BAGiBD,OAHjB,6BAIcE,QAJd,qBAIsCC,QAJtC,uBAKSU,eALT,4CAAJ;AAQA,WAAOhB,KAAP;AACD;;AAED,WAASe,qBAAT,CAA+BZ,OAA/B,EAAwCC,KAAxC,EAA+CC,QAA/C,EAAyDC,QAAzD,EAAmEC,WAAnE,EAAgFC,WAAhF,EAA6FK,WAA7F,EAA0G;AACxG,QAAIG,iCAA+BT,WAA/B,WAAgDA,WAApD;AACA,QAAIP,4CACyBgB,eADzB,sBACyDR,WADzD,SACwEK,WADxE,6BAEKT,KAFL,+BAGiBD,OAHjB,6BAIcE,QAJd,qBAIsCC,QAJtC,uBAKSU,eALT,4CAAJ;AAQA,WAAOhB,KAAP;AACD;;AAUD,WAASU,yBAAT,CAAmCP,OAAnC,EAA4CC,KAA5C,EAAmDC,QAAnD,EAA6DC,QAA7D,EAAuEC,WAAvE,EAAoFC,WAApF,EAAiG;AAC/F,QAAIQ,+BAA6BT,WAA7B,WAA8CA,WAAlD;AACA,QAAIP,4CACwBiB,aADxB,uBACsDD,eADtD,kBACkFR,WADlF,mCAEKJ,KAFL,+BAGiBD,OAHjB,6BAIcE,QAJd,qBAIsCC,QAJtC,mDAAJ;AAQA,WAAON,KAAP;AACD;;AAED,WAASc,wBAAT,CAAkCX,OAAlC,EAA2CC,KAA3C,EAAkDC,QAAlD,EAA4DC,QAA5D,EAAsEC,WAAtE,EAAmFC,WAAnF,EAAgGK,WAAhG,EAA6G;AAC3G,QAAIG,+BAA6BT,WAA7B,WAA8CA,WAAlD;AACA,QAAIP,4CACwBiB,aADxB,uBACsDD,eADtD,kBACkFR,WADlF,SACiGK,WADjG,6BAEKT,KAFL,+BAGiBD,OAHjB,6BAIcE,QAJd,qBAIsCC,QAJtC,mDAAJ;AAQA,WAAON,KAAP;AACD;;;;AApQMrB,O;;;;;;;;;;;;;;;;;;;;;AAEDuC,yB,GAAsB,K;AACtBC,0B,GAAuB;AAC3B,aAAK,SADsB;AAE3B,aAAK,aAFsB;AAG3B,aAAK,aAHsB;AAI3B,aAAK,cAJsB;AAK3B,aAAK;AALsB,O;AAQvBC,wB,GAAqB;AACzB,aAAK,QADoB;AAEzB,aAAK;AAFoB,O;AAKrBC,uB,GAAoB;AACxB,eAAO,KADiB;AAExB,eAAO,KAFiB;AAGxB,eAAO,KAHiB;AAIxB,eAAO,KAJiB;AAKxB,iBAAS;AALe,O;AAQpBC,+B,GAA4B;AAChC,eAAO,WADyB;AAEhC,eAAO,WAFyB;AAGhC,eAAO;AAHyB,O;;mCAMrBC,iB;AAEX,mCAAYC,eAAZ,EAA6BC,OAA7B,EAAsCC,UAAtC,EAAkDC,aAAlD,EAAiE;AAAA;;AAC/D,eAAKD,UAAL,GAAkBA,UAAlB;AACA,eAAKC,aAAL,GAAqBA,aAArB;;AAEA,cAAIC,QAAQH,QAAQG,KAApB;AACA,eAAKJ,eAAL,GAAuBA,eAAvB;AACA,eAAKI,KAAL,GAAaA,SAASV,mBAAtB;;AAEA,eAAKW,iBAAL,CAAuBL,eAAvB;AACD;;AAED;;;;;;;;4CAIkBM,Y,EAAc;AAAA;;AAC9B,gBAAIC,KAAKpD,EAAES,IAAF,CAAO,KAAKuC,aAAL,CAAmBK,MAAnB,EAAP,EAAoC,EAAC,MAAMF,YAAP,EAApC,CAAT;AACA,gBAAIC,EAAJ,EAAQ;AACN,qBAAO,KAAKJ,aAAL,CAAmBM,cAAnB,CAAkCF,GAAG7C,IAArC,EACNgD,IADM,CACD,cAAM;AACV,sBAAKC,iBAAL,GAAyBJ,GAAGK,IAAH,CAAQC,EAAjC;AACA,uBAAON,EAAP;AACD,eAJM,CAAP;AAKD,aAND,MAMO;AACL,qBAAOO,QAAQC,MAAR,8BAA0CT,YAA1C,gBAAP;AACD;AACF;;;8CAKmB;AAClB,gBAAIU,YAAYC,gBAAhB;AACA,gBAAI,KAAKN,iBAAL,KAA2B,UAA/B,EAA2C;AACzCK,0BAAYE,mBAAZ;AACD;AACD,mBAAO,KAAKC,cAAL,CAAoBH,SAApB,CAAP;AACD;;;qCAEUhE,K,EAAO6B,Q,EAAUC,Q,EAAUmB,O,EAAS;AAAA;;AAAA,gBACxCmB,UADwC,GACXnB,OADW,CACxCmB,UADwC;AAAA,gBAC5BC,aAD4B,GACXpB,OADW,CAC5BoB,aAD4B;;AAE7C,gBAAItC,cAAcuC,KAAKC,IAAL,CAAUH,aAAa,IAAvB,CAAlB;;AAEAC,4BAAgBA,iBAAiB,KAAjC;AACA,gBAAIrC,cAAca,kBAAkBwB,aAAlB,CAAlB;;AAEA;AACA,gBAAIG,gBAAgBrE,EAAEsE,OAAF,CAAUzE,KAAV,EAAiB,YAAjB,CAApB;AACA,gBAAI0E,WAAWvE,EAAEG,GAAF,CAAMkE,aAAN,EAAqB,UAACxE,KAAD,EAAQ2E,UAAR,EAAuB;AACzD,kBAAIhD,UAAUxB,EAAEG,GAAF,CAAMN,KAAN,EAAa,QAAb,EAAuB4E,IAAvB,CAA4B,IAA5B,CAAd;AACA,kBAAIhD,QAAQe,qBAAqBgC,UAArB,CAAZ;;AAEA,kBAAI1C,UAAU,OAAK0B,iBAAnB;AACA,kBAAInC,QAAQE,qBAAqBC,OAArB,EAA8BC,KAA9B,EAAqCC,QAArC,EAA+CC,QAA/C,EAAyDC,WAAzD,EAAsEC,WAAtE,EAAmFC,OAAnF,CAAZ;;AAEAT,sBAAQD,gBAAgBC,KAAhB,CAAR;AACA,qBAAO,OAAK2C,cAAL,CAAoB3C,KAApB,CAAP;AACD,aATc,CAAf;;AAWA,mBAAOsC,QAAQe,GAAR,CAAYH,QAAZ,EAAsBhB,IAAtB,CAA2B,mBAAW;AAC3C,qBAAOvD,EAAEE,OAAF,CAAUyE,OAAV,CAAP;AACD,aAFM,CAAP;AAGD;;;oCAES9E,K,EAAO6B,Q,EAAUC,Q,EAAUmB,O,EAAS;AAAA;;AAAA,gBACvCmB,UADuC,GACVnB,OADU,CACvCmB,UADuC;AAAA,gBAC3BC,aAD2B,GACVpB,OADU,CAC3BoB,aAD2B;;AAE5C,gBAAItC,cAAcuC,KAAKC,IAAL,CAAUH,aAAa,IAAvB,CAAlB;;AAEAC,4BAAgBA,iBAAiB,KAAjC;AACA,gBAAIrC,cAAca,kBAAkBwB,aAAlB,CAAlB;;AAEA;AACA,gBAAIG,gBAAgBrE,EAAEsE,OAAF,CAAUzE,KAAV,EAAiB,YAAjB,CAApB;AACA,gBAAI0E,WAAWvE,EAAEG,GAAF,CAAMkE,aAAN,EAAqB,UAACxE,KAAD,EAAQ2E,UAAR,EAAuB;AACzD,kBAAIhD,UAAUxB,EAAEG,GAAF,CAAMN,KAAN,EAAa,QAAb,EAAuB4E,IAAvB,CAA4B,IAA5B,CAAd;AACA,kBAAIhD,QAAQgB,mBAAmB+B,UAAnB,CAAZ;AACA,kBAAItC,cAAclC,EAAE4E,QAAF,CAAW,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,CAAX,EAAkCV,aAAlC,IAAmDA,aAAnD,GAAmE,KAArF;AACAhC,4BAAcS,0BAA0BT,WAA1B,CAAd;;AAEA,kBAAIJ,UAAU,OAAK0B,iBAAnB;AACA,kBAAInC,QAAQY,oBAAoBT,OAApB,EAA6BC,KAA7B,EAAoCC,QAApC,EAA8CC,QAA9C,EAAwDC,WAAxD,EAAqEC,WAArE,EAAkFK,WAAlF,EAA+FJ,OAA/F,CAAZ;;AAEAT,sBAAQD,gBAAgBC,KAAhB,CAAR;AACA,qBAAO,OAAK2C,cAAL,CAAoB3C,KAApB,CAAP;AACD,aAXc,CAAf;;AAaA,mBAAOsC,QAAQe,GAAR,CAAYH,QAAZ,EAAsBhB,IAAtB,CAA2B,mBAAW;AAC3C,qBAAOvD,EAAEE,OAAF,CAAUyE,OAAV,CAAP;AACD,aAFM,CAAP;AAGD;;;kDAEuBE,O,EAAShF,K,EAA2B;AAAA,gBAApBC,WAAoB,uEAAN,IAAM;;AAC1D,mBAAOH,yBAAyBkF,OAAzB,EAAkChF,KAAlC,EAAyCC,WAAzC,CAAP;AACD;;;yCAEcuB,K,EAAO;AACpB,gBAAIyD,WAAW;AACbC,qBAAO,GADM;AAEbC,sBAAQ,aAFK;AAGb7B,4BAAc,KAAKN,eAHN;AAIboC,sBAAQ5D,KAJK;AAKb6D,6BAAe,KAAKjC;AALP,aAAf;;AAQA,mBAAO,KAAKF,UAAL,CAAgBoC,iBAAhB,CAAkC;AACvCC,mBAAK,iBADkC;AAEvCC,sBAAQ,MAF+B;AAGvCC,oBAAM;AACJC,yBAAS,CAACT,QAAD;AADL;AAHiC,aAAlC,EAONvB,IAPM,CAOD,oBAAY;AAChB,kBAAIoB,UAAUa,SAASF,IAAT,CAAcX,OAA5B;AACA,kBAAIA,QAAQ,GAAR,CAAJ,EAAkB;AAChB,uBAAOA,QAAQ,GAAR,EAAarE,MAApB;AACD,eAFD,MAEO;AACL,uBAAO,IAAP;AACD;AACF,aAdM,CAAP;AAeD;;;;;;;;AA6EGwD,sB;AAMAxB,mB,GAAgB,wB;AA4BhByB,yB,qCACsBzB,a","file":"zabbixDBConnector.js","sourcesContent":["import _ from 'lodash';\n\nconst DEFAULT_QUERY_LIMIT = 10000;\nconst HISTORY_TO_TABLE_MAP = {\n  '0': 'history',\n  '1': 'history_str',\n  '2': 'history_log',\n  '3': 'history_uint',\n  '4': 'history_text'\n};\n\nconst TREND_TO_TABLE_MAP = {\n  '0': 'trends',\n  '3': 'trends_uint'\n};\n\nconst consolidateByFunc = {\n  'avg': 'AVG',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nconst consolidateByTrendColumns = {\n  'avg': 'value_avg',\n  'min': 'value_min',\n  'max': 'value_max'\n};\n\nexport class ZabbixDBConnector {\n\n  constructor(sqlDataSourceId, options, backendSrv, datasourceSrv) {\n    this.backendSrv = backendSrv;\n    this.datasourceSrv = datasourceSrv;\n\n    let limit = options.limit;\n    this.sqlDataSourceId = sqlDataSourceId;\n    this.limit = limit || DEFAULT_QUERY_LIMIT;\n\n    this.loadSQLDataSource(sqlDataSourceId);\n  }\n\n  /**\n   * Try to load DS with given id to check it's exist.\n   * @param {*} datasourceId ID of SQL data source\n   */\n  loadSQLDataSource(datasourceId) {\n    let ds = _.find(this.datasourceSrv.getAll(), {'id': datasourceId});\n    if (ds) {\n      return this.datasourceSrv.loadDatasource(ds.name)\n      .then(ds => {\n        this.sqlDataSourceType = ds.meta.id;\n        return ds;\n      });\n    } else {\n      return Promise.reject(`SQL Data Source with ID ${datasourceId} not found`);\n    }\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testSQLDataSource() {\n    let testQuery = TEST_MYSQL_QUERY;\n    if (this.sqlDataSourceType === 'postgres') {\n      testQuery = TEST_POSTGRES_QUERY;\n    }\n    return this.invokeSQLQuery(testQuery);\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let {intervalMs, consolidateBy} = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = HISTORY_TO_TABLE_MAP[value_type];\n\n      let dialect = this.sqlDataSourceType;\n      let query = buildSQLHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, dialect);\n\n      query = compactSQLQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    let {intervalMs, consolidateBy} = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = TREND_TO_TABLE_MAP[value_type];\n      let valueColumn = _.includes(['avg', 'min', 'max'], consolidateBy) ? consolidateBy : 'avg';\n      valueColumn = consolidateByTrendColumns[valueColumn];\n\n      let dialect = this.sqlDataSourceType;\n      let query = buildSQLTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn, dialect);\n\n      query = compactSQLQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  handleGrafanaTSResponse(history, items, addHostName = true) {\n    return convertGrafanaTSResponse(history, items, addHostName);\n  }\n\n  invokeSQLQuery(query) {\n    let queryDef = {\n      refId: 'A',\n      format: 'time_series',\n      datasourceId: this.sqlDataSourceId,\n      rawSql: query,\n      maxDataPoints: this.limit\n    };\n\n    return this.backendSrv.datasourceRequest({\n      url: '/api/tsdb/query',\n      method: 'POST',\n      data: {\n        queries: [queryDef],\n      }\n    })\n    .then(response => {\n      let results = response.data.results;\n      if (results['A']) {\n        return results['A'].series;\n      } else {\n        return null;\n      }\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nfunction convertGrafanaTSResponse(time_series, items, addHostName) {\n  var hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid'); //uniqBy is needed to deduplicate\n  let grafanaSeries = _.map(time_series, series => {\n    let itemid = series.name;\n    var item = _.find(items, {'itemid': itemid});\n    var alias = item.name;\n    if (_.keys(hosts).length > 1 && addHostName) { //only when actual multi hosts selected\n      var host = _.find(hosts, {'hostid': item.hostid});\n      alias = host.name + \": \" + alias;\n    }\n    // CachingProxy deduplicates requests and returns one time series for equal queries.\n    // Clone is needed to prevent changing of series object shared between all targets.\n    let datapoints = _.cloneDeep(series.points);\n    return {\n      target: alias,\n      datapoints: datapoints\n    };\n  });\n\n  return _.sortBy(grafanaSeries, 'target');\n}\n\nfunction compactSQLQuery(query) {\n  return query.replace(/\\s+/g, ' ');\n}\n\nfunction buildSQLHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, dialect = 'mysql') {\n  if (dialect === 'postgres') {\n    return buildPostgresHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n  } else {\n    return buildMysqlHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n  }\n}\n\nfunction buildSQLTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn, dialect = 'mysql') {\n  if (dialect === 'postgres') {\n    return buildPostgresTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n  } else {\n    return buildMysqlTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n  }\n}\n\n///////////\n// MySQL //\n///////////\n\nfunction buildMysqlHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock DIV ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT itemid AS metric, ${time_expression} AS time_sec, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY ${time_expression}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nfunction buildMysqlTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock DIV ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT itemid AS metric, ${time_expression} AS time_sec, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY ${time_expression}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nconst TEST_MYSQL_QUERY = `SELECT itemid AS metric, clock AS time_sec, value_avg AS value FROM trends_uint LIMIT 1`;\n\n////////////////\n// PostgreSQL //\n////////////////\n\nconst itemid_format = 'FM99999999999999999999';\n\nfunction buildPostgresHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${itemid_format}') AS metric, ${time_expression} AS time, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nfunction buildPostgresTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${itemid_format}') AS metric, ${time_expression} AS time, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nconst TEST_POSTGRES_QUERY = `\n  SELECT to_char(itemid, '${itemid_format}') AS metric, clock AS time, value_avg AS value\n  FROM trends_uint LIMIT 1\n`;\n"]}